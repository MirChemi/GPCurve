#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Feb 03, 2025 01:45:45 AM +03  platform: Windows NT

import sys
import tkinter as tk
from tkinter import ttk
from tkinterdnd2 import DND_FILES, TkinterDnD


import csv
import configparser
from itertools import zip_longest
from statistics import mean
import os

import clipboard
import pdfplumber
import numpy as np
from matplotlib import pyplot, widgets
from scipy.optimize import curve_fit

from scripts import linreg, const_extr
import gpcurve

_debug = True # False to eliminate debug printing from callback functions.

base_color = 'blue', 'red', 'green', 'black', 'yellow', 'magenta', 'cyan'
gauss_color = 'cyan', 'magenta', 'yellow', 'black', 'green', 'red', 'blue'
plot_number = 0

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = TkinterDnD.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1, _use, _amp, _cen, _lock_cen, _sigma, _config
    _config = configparser.ConfigParser()
    _config.read(os.path.join(os.path.dirname(__file__), 'config.ini'))
    _top1 = root
    _w1 = gpcurve.Toplevel1(_top1)
    _w1.lb1.insert(1, "drag GPC txt data file")
    _w1.lb1.drop_target_register(DND_FILES)
    _w1.lb1.dnd_bind('<<Drop>>', lambda e: drop_file(_w1.lb1, e.data))
    _w1.lb2.insert(1, "drag constants pdf data file or folder")
    _w1.lb2.drop_target_register(DND_FILES)
    _w1.lb2.dnd_bind('<<Drop>>', lambda e: drop_file(_w1.lb2, e.data))
    if _config['conf']['const_path'] != '':
        _w1.lb2.insert(2, _config['conf']['const_path'])

    _w1.e_ff.insert(0, _config['conf']['flag1'])
    _w1.e_sf.insert(0, _config['conf']['flag2'])
    _w1.e_sl.insert(0, _config['conf']['lgm1'])
    _w1.e_el.insert(0, _config['conf']['lgm2'])


    _use = [_w1.use1, _w1.use2, _w1.use3, _w1.use4, _w1.use5, _w1.use6]
    _amp = [_w1.a1, _w1.a2, _w1.a3, _w1.a4, _w1.a5, _w1.a6]
    _cen = [_w1.cn1, _w1.cn2, _w1.cn3, _w1.cn4, _w1.cn5, _w1.cn6]
    _lock_cen = [_w1.lock1, _w1.lock2, _w1.lock3, _w1.lock4, _w1.lock5, _w1.lock6]
    _sigma = [_w1.s1, _w1.s2, _w1.s3, _w1.s4, _w1.s5, _w1.s6]

    root.mainloop()

def drop_file(listbox, data):
    listbox.insert(1, data)
    listbox.delete(2)


def start():
    def copy_spectra(event):
        to_copy = ''
        for i in range(len(x)):
            to_copy += f'{x[i]}\t{y[i]}\n'
        clipboard.copy(to_copy)

    def copy_peak(event):
        to_copy = ''
        for i in range(len(x_peak)):
            to_copy += f'{x_peak[i]}\t{y_peak[i]}\n'
        clipboard.copy(to_copy)

    def all_to_csv(event):
        csv_filename = str(_w1.lb1.get(1)).replace('.txt', '_GPCurve.csv')
        csv_data = [x, y, x_peak, y_peak]
        header_list = ['x_spectra', 'y_spectra', 'x_peak', 'y_peak']
        if len(_amp) > 0:
            csv_data.append(x_peak)
            header_list.append('x_fit')
            csv_data.append(fit)
            header_list.append('y_fit')
            for gauss_number in range(len(_amp)):
                csv_data.append(x_peak)
                header_list.append('x_gauss_' + str(gauss_number + 1))
                csv_data.append(gauss_curve[gauss_number])
                header_list.append('y_gauss_' + str(gauss_number + 1))

        with open(csv_filename, 'w', ) as f:
            writer = csv.writer(f)
            writer.writerow(header_list)
            writer.writerows(zip_longest(*csv_data, fillvalue=''))

    def show_sec_der(event):
        x_der = []
        y_der = []
        for i in range(1, len(x) - 1):
            x_der.append(x[i])
            dy1 = (y[i] - y[i - 1]) / (x[i] - x[i - 1])
            dy2 = (y[i + 1] - y[i]) / (x[i + 1] - x[i])
            y_der.append((dy2 - dy1) / ((x[i + 1] - x[i - 1]) / 2))
        x_der_smoothed = np.empty(0)
        y_der_smoothed = np.empty(0)
        step = int(_config['conf']['der_smoothing_level'])
        for i in range(0, len(x_der), step):
            x_der_smoothed = np.append(x_der_smoothed, mean(x_der[i:i + step - 1]))
            y_der_smoothed = np.append(y_der_smoothed, mean(y_der[i:i + step - 1]))
        fig_d, axes_d = pyplot.subplots(1, 1, figsize=(9.0, 8.0), sharex=True)
        ax1_d = axes_d
        ax1_d.scatter(x_der_smoothed, y_der_smoothed)
        pyplot.show()

    global ax1, plot_number, _top1, _w1, _use, _amp, _cen, _lock_cen, _sigma, _config

    _config.read(os.path.join(os.path.dirname(__file__), 'config.ini'))
    flag1 = str(_w1.e_ff.get())
    flag2 = str(_w1.e_sf.get())
    input1 = str(_w1.lb1.get(1))
    ex_name = input1.split("/")[-1]
    ex_name = ex_name.split(".")[0]
    input2 = str(_w1.lb2.get(1))

    if input2 != '':
        _config.set('conf', 'const_path', input2)
    _config.set('conf', 'flag1', flag1)
    _config.set('conf', 'flag2', flag2)
    with open(os.path.join(os.path.dirname(__file__), 'config.ini'), 'w') as configfile:
        _config.write(configfile)

    if all([_w1.e_c0.get(), _w1.e_c1.get(), _w1.e_c2.get(), _w1.e_c3.get()]):
        const = [float(_w1.e_c0.get()), float(_w1.e_c1.get()), float(_w1.e_c2.get()), float(_w1.e_c3.get())]
    else:
        const = const_extr.extract_const(input2, input1)
    print('C0 - C3 = ' + str(const))

    with open(_w1.lb1.get(1), encoding="utf8") as f:
        data = f.readlines()
    while data and not data[0].startswith(flag1):
        data.pop(0)
    while data and not data[-1].startswith(flag2):
        data.pop(-1)

    x = []
    vol = []
    y = []
    #if bool(do_fix.get()):
    #    print('lg intensity fixed')
    if _config.getboolean('conf', 'lin_calc'):
        print('lin_calc')
    for i in range(len(data)):
        data[i] = data[i].replace('\n', '').replace(',', '.')
        li = data[i].split('\t')
        vl = float(li[0])
        vol.append(vl)
        if _config.getboolean('conf', 'lin_calc'):
            c_lgm1 = float(_config['conf']['lgm2'])
            c_lgm2 = float(_config['conf']['lgm2'])
            c_vol1 = float(_config['conf']['vol1'])
            c_vol2 = float(_config['conf']['vol2'])

            b1 = (c_lgm2 - c_lgm1) / (c_vol2 - c_vol1)
            b0 = c_lgm1 - b1 * c_vol1
            lgm = b0 + vl * b1
        else:
            lgm = const[0] + const[1] * vl + const[2] * vl * vl + const[3] * vl ** 3
        x.append(lgm)
        y.append(float(li[2]))

    for i in range(len(y)):
        y_fix = 1
        #if bool(do_fix.get()) and i > 0:
        #    y_fix = (abs(vol[i] - vol[i - 1]) / abs(x[i] - x[i - 1])) ** 1
        y[i] = y[i] * y_fix

    y_min = min(y)
    for i in range(len(y)):
        y[i] = y[i] - y_min

    y_max = max(y)
    for i in range(len(y)):
        y[i] = y[i] / y_max

    # to change cubic dependence between vol and lgM to linear one
    if _config.getboolean('conf', 'lin_approx'):
        vol_for_lin = []
        lg_for_lin = []
        for i in range(len(x)):
            if y[i] > 0.1:
                vol_for_lin.append(vol[i])
                lg_for_lin.append(x[i])
        b0, b1 = linreg.estimate_coef(np.array(vol_for_lin), np.array(lg_for_lin))
        x = []
        for i in range(len(vol)):
            x.append(b0 + b1 * vol[i])

    index_max = y.index(max(y))
    plot_number += 1
    if bool(_w1.new_fig.get()):
        fig, ax1 = pyplot.subplots(figsize=(9.0, 7.0), sharex=True)
        ax1.set_position([0.07, 0.1, 0.8, 0.8])
        ax1.set_xlabel('lgM')
        plot_number = 0
    if bool(_w1.clean.get()):
        ax1.plot(x, y, color=base_color[plot_number % len(base_color)], label=ex_name)
        ax1.legend()
    else:
        ax1.plot(x, y, 'k--', label=ex_name)
    if bool(_w1.new_fig.get()):
        ax1.set_xlim(ax1.get_xlim()[::-1])
        ax_copy = fig.add_axes([0.9, 0.2, 0.1, 0.075])
        b_copy = widgets.Button(ax_copy, 'Copy\nspectra')
        b_copy.on_clicked(copy_spectra)

        ax_copy_p = fig.add_axes([0.9, 0.3, 0.1, 0.075])
        b_copy_p = widgets.Button(ax_copy_p, 'Copy\npeak')
        b_copy_p.on_clicked(copy_peak)

        ax_copy_a = fig.add_axes([0.9, 0.4, 0.1, 0.075])
        b_copy_a = widgets.Button(ax_copy_a, 'Save\nto csv')
        b_copy_a.on_clicked(all_to_csv)

        ax_der = fig.add_axes([0.9, 0.5, 0.1, 0.075])
        b_der = widgets.Button(ax_der, 'Show\n2nd der')
        b_der.on_clicked(show_sec_der)
    x_np = np.array(x)
    y_np = np.array(y)

    point1 = str(_w1.e_sl.get())
    point2 = str(_w1.e_el.get())
    count = 0
    if 'auto' in point1:
        index_left_min = index_max
        flag = True
        while flag:
            if y[index_left_min - 2] <= y[index_left_min]:
                index_left_min -= 1
            else:
                flag = False
    else:
        count = 1
        index_left_min = x.index(min(x, key=lambda xx: abs(xx - float(point1))))

    if 'auto' in point2:
        index_right_min = index_max
        flag = True
        while flag:
            if y[index_right_min + 2] <= y[index_right_min]:
                index_right_min += 1
            else:
                flag = False
    else:
        if count == 1 and point1 <= point2:
            raise 'start lgM must be greater then end lgM'
        index_right_min = x.index(min(x, key=lambda xx: abs(xx - float(point2))))

    x_line = x_np[index_left_min], x_np[index_right_min]
    y_base = min(y_np[index_left_min], y_np[index_right_min])
    y_line = [y_base, y_base]

    baseline1 = str(_w1.e_sb.get())
    baseline2 = str(_w1.e_eb.get())
    if baseline1:
        y_line[0] = float(baseline1)
    if baseline2:
        y_line[1] = float(baseline2)

    k_line = -(y_line[1] - y_line[0]) / (x_line[0] - x_line[1])
    b_line = y_line[0] - k_line * x_line[0]
    if not bool(_w1.clean.get()):
        ax1.plot(x_line, y_line, color=base_color[plot_number % len(base_color)], linestyle='dashdot', marker='x')

    x_peak = []
    vol_peak = []
    y_peak = []
    m_peak = []

    for i in range(index_right_min - index_left_min + 1):
        x_peak.append(x[i + index_left_min])
        vol_peak.append(vol[i + index_left_min])
        m_peak.append(10 ** x[i + index_left_min])
        y_peak.append(y[i + index_left_min] - (k_line * x[i + index_left_min] + b_line))

    def calculate_peak(x_pe, y_pe, text_color):

        m_avg = []
        slice_start = []
        slice_end = []
        slice_avg = []
        i_start = []
        i_end = []
        i_avg = []
        slice_area = []
        sa_m = []
        sa_d_m = []

        for sl in range(len(x_pe) - 1):
            m_avg.append((10 ** x_pe[sl] + 10 ** x_pe[sl + 1]) / 2)
            slice_start.append(x_pe[sl])
            slice_end.append(x_pe[sl + 1])
            slice_avg.append((slice_start[sl] + slice_end[sl]) / 2)
            i_start.append(y_pe[sl])
            i_end.append(y_pe[sl + 1])
            i_avg.append((i_start[sl] + i_end[sl]) / 2)
            slice_area.append(i_avg[sl] * abs(slice_end[sl] - slice_start[sl]))
            sa_m.append(slice_area[sl] * m_avg[sl])
            sa_d_m.append(slice_area[sl] / m_avg[sl])

        m_n = sum(slice_area) / sum(sa_d_m)
        m_w = sum(sa_m) / sum(slice_area)
        mwd = m_w / m_n

        _w1.Text1.insert(tk.END, 'Mn = ' + str(round(m_n)) + '\t', text_color)
        _w1.Text1.insert(tk.END, 'Mw = ' + str(round(m_w)) + '\t', text_color)
        _w1.Text1.insert(tk.END, 'Mw/Mn = ' + str(round(mwd, 3)) + '\n', text_color)
        _w1.Text1.insert(tk.END, 'peak area = ' + str(round(sum(slice_area), 4)) + '\n', text_color)
        _w1.Text1.insert(tk.END, 'number of slices = ' + str(len(x_pe) - 1) + '\n', text_color)

    calculate_peak(x_peak, y_peak, base_color[plot_number % len(base_color)])
    if not bool(_w1.clean.get()):
        ax1.plot(x_peak, y_peak, color=base_color[plot_number % len(base_color)])
    if any(bool(_use[i].get()) for i in range(6)):
        def func(x1, *params):
            y1 = np.zeros_like(x1)
            for i in range(0, len(params), 3):
                ctr1 = params[i]
                amp1 = params[i + 1]
                wid1 = params[i + 2]
                y1 = y1 + amp1 * np.exp(-0.5 * ((x1 - ctr1) / wid1) ** 2)
            return y1

        guess = []
        down_bounds = []
        up_bounds = []
        eps = 0.000000000000001

        for i in range(len(_amp)):
            guess.append(_cen[i])
            if _lock_cen[i]:
                down_bounds.append(_cen[i] - eps)
                up_bounds.append(_cen[i] + eps)
            else:
                down_bounds.append(-np.inf)
                up_bounds.append(np.inf)

            guess.append(_amp[i])
            down_bounds.append(0)
            up_bounds.append(np.inf)

            guess.append(_sigma[i])
            down_bounds.append(-np.inf)
            up_bounds.append(np.inf)

        popt, pcov = curve_fit(func, x_peak, y_peak, p0=guess, bounds=[down_bounds, up_bounds], maxfev=100000)
        fit = func(x_peak, *popt)
        ax1.plot(x_peak, fit, color='orange')
        calculate_peak(x_peak, fit, 'orange')
        gauss_curve = []
        print('center--amplitude--sigma')
        for i in range(len(_amp)):
            a = [float(popt[i * 3]), float(popt[i * 3 + 1]), float(popt[i * 3 + 2])]
            a = np.array(a)
            print(a)
            gauss_curve.append(func(x_peak, *a))
            calculate_peak(x_peak, gauss_curve[i], gauss_color[i % len(gauss_color)])
            ax1.plot(x_peak, gauss_curve[i], color=gauss_color[i % len(gauss_color)])
    pyplot.show()

def uncheck_gauss(*args):
    if _debug:
        print('main_support.uncheck_gauss')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

if __name__ == '__main__':
    gpcurve.start_up()




